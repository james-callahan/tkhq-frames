<!doctype html>
<html class="no-js" lang="">

<head>
  <meta charset="utf-8">
  <title>Turnkey Recovery</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      text-align: center;
      font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
      max-width: 1024px;
      margin: auto;
    }
    label {
      display:inline-block;
      width: 8em;
    }
    input[type=text] {
      width: 40em;
      margin: 0.5em;
      font-family: 'Courier New', Courier, monospace;
      font-size: 1em;
      height: 1.8em;
      color: rgb(18, 87, 18);
      border: 1px rgb(217, 240, 221) solid;
      border-radius: 4px;
    }
    input:disabled {
      background-color: rgb(239, 243, 240);
    }
    #decrypted {
      width: 60em;
      background-color: rgb(58, 152, 81);
      color: white;
      height: 2em;
      font-weight: bold;
      text-align: center;
    }
    #clear {
      color: white;
      width: 7em;
      font-size: 1em;
      padding: 0.38em;
      border-radius: 4px;
      background-color: rgb(187, 100, 100);
      border: 1px rgb(112, 42, 42) solid;
      cursor: pointer;
    }
    #inject, #stamp {
      color: white;
      width: 7em;
      font-size: 1em;
      padding: 0.38em;
      border-radius: 4px;
      background-color: rgb(50, 44, 44);
      border: 1px rgb(33, 33, 33) solid;
      cursor: pointer;
    }
    #message-log {
      border: 1px #2a2828 solid;
      padding: 0 0.7em;
      border-radius: 4px;
      margin-top: 2em;
      max-width: 800px;
      margin: auto;
    }
    #message-log p {
      font-size: 0.9em;
      text-align: left;
      word-break: break-all;
    }
    .hidden { display: none; }
  </style>
</head>

<body>
  <h2>Init Recovery</h2>
  <p><em>This public key will be sent along with your email inside of a new <code>INIT_USER_EMAIL_RECOVERY</code> activity</em></p>
  <form>
    <label>Embedded key</label>
    <input type="text" name="embedded-key" id="embedded-key" disabled/>
    <button id="clear">Reset Key</button>
  </form>
  <br>
  <br>
  <br>
  <h2>Inject Recovery Bundle</h2>
  <p><em>The recovery bundle comes from your email. We can also simulate this locally: see instructions <a href="https://github.com/tkhq/recovery#running-a-fake-recovery" target="_blank">here</a>. A recovery bundle is composed of a public key and an encrypted payload. The payload is encrypted to this document's embedded key (stored in local storage and displayed above). The scheme relies on <a target="_blank" href="https://datatracker.ietf.org/doc/rfc9180/">HPKE (RFC 9180)</a></em>.</p>
  <form>
    <label>Bundle</label>
    <input type="text" name="recovery-bundle" id="recovery-bundle"/>
    <button id="inject">Inject Bundle</button>
  </form>
  <br>
  <br>
  <br>
  <h2>Stamp</h2>
  <p><em>Once you've injected the recovery bundle, the recovery credential is ready to sign. A new <code>RECOVER</code> activity for example. This iframe doesn't know anything about Turnkey activity however, it's a simple stamper!</em></p>
  <form>
    <label>Payload</label>
    <input type="text" name="payload" id="payload"/>
    <button id="stamp">Stamp</button>
  </form>
  <br>
  <br>
  <br>
  <h2>Message log</h2>
  <p><em>Below we display a log of the messages sent / received. The forms above send messages, and the code communicates results by sending events via the <code>postMessage</code> API.</em></p>
  <div id="message-log"></div>

  <!--
    Script defining important helpers.
    These helpers are unit-testable, so most of the logic should be written here.
  -->
  <script>
    window.TKHQ = function() {
      /** constant for LocalStorage */
      var TURNKEY_EMBEDDED_KEY = "TURNKEY_EMBEDDED_KEY"

      /**
       * Creates a new public/private key pair and persists it in localStorage
       */
      var initEmbeddedKey = async function() {
        var retrievedKey = await getEmbeddedKey();
        if (retrievedKey === null) {
          var targetKey = await generateTargetKey();
          setEmbeddedKey(targetKey)
        } else {
          // Nothing to do, key is correctly initialized!
        }
      }

      /*
      * Generate a key to encrypt to and export it as a JSON Web Key.
      */
      var generateTargetKey = async function() {
        var p256key = await crypto.subtle.generateKey({
          name: 'ECDSA',
          namedCurve: 'P-256',
        }, true, ['sign',]);

        return await crypto.subtle.exportKey("jwk", p256key.privateKey);
      }

      /**
       * Gets the current embedded private key JWK. Returns `null` if not found.
       */
      var getEmbeddedKey = function() {
        var jwtKey = window.localStorage.getItem(TURNKEY_EMBEDDED_KEY)
        if (jwtKey === null || jwtKey === undefined || jwtKey === "") {
          return null
        } else {
          return JSON.parse(jwtKey);
        }
      }

      var setEmbeddedKey = function(targetKey) {
        return window.localStorage.setItem(TURNKEY_EMBEDDED_KEY, JSON.stringify(targetKey))
      }

      var clearEmbeddedKey = function() {
        window.localStorage.removeItem(TURNKEY_EMBEDDED_KEY)
      }

      /**
       * Takes a hex string (e.g. "e4567ab") and returns an array buffer (Uint8Array)
       * @param {string} hexString
       * @returns {Uint8Array}
       */
      var uint8arrayFromHexString = function(hexString) {
        var res = new Uint8Array(hexString.match(/../g).map(h=>parseInt(h,16)));
        return res
      }

      /**
        * Takes a Uint8Array and returns a hex string
        * @param {Uint8Array} buffer
        * @return {string}
        */
      var uint8arrayToHexString = function(buffer) {
        return [...buffer]
            .map(x => x.toString(16).padStart(2, '0'))
            .join('');
      }

      /**
       * Additional Associated Data (AAD) in the format dictated by the enclave_encrypt crate.
       */
      var additionalAssociatedData = function(
        senderPubBuf,
        receiverPubBuf,
      ) {
        var s = Array.from(new Uint8Array(senderPubBuf));
        var r = Array.from(new Uint8Array(receiverPubBuf));
        return new Uint8Array([...s, ...r]);
      }

      /**
       * Encodes a buffer into base64url
       */
      function base64urlEncode(byteArray) {
        return btoa(Array.from(new Uint8Array(byteArray)).map(val => {
          return String.fromCharCode(val);
        }).join('')).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
      }

      /**
       * `SubtleCrypto.sign(...)` outputs signature in IEEE P1363 format:
       * - https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign#ecdsa
       *
       * Turnkey expects the signature encoding to be DER-encoded ASN.1:
       * - https://github.com/tkhq/tkcli/blob/7f0159af5a73387ff050647180d1db4d3a3aa033/src/internal/apikey/apikey.go#L149
       *
       * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts#L114
       *
       * Transform an ECDSA signature in IEEE 1363 encoding to DER encoding.
       *
       * @param {Uint8Array} ieee the ECDSA signature in IEEE encoding
       * @return ECDSA signature in DER encoding
       */
      function convertEcdsaIeee1363ToDer(ieee) {
        if (ieee.length % 2 != 0 || ieee.length == 0 || ieee.length > 132) {
          throw new Error(
            "Invalid IEEE P1363 signature encoding. Length: " + ieee.length
          );
        }
        const r = toUnsignedBigNum(ieee.subarray(0, ieee.length / 2));
        const s = toUnsignedBigNum(ieee.subarray(ieee.length / 2, ieee.length));
        let offset = 0;
        const length = 1 + 1 + r.length + 1 + 1 + s.length;
        let der;
        if (length >= 128) {
          der = new Uint8Array(length + 3);
          der[offset++] = 48;
          der[offset++] = 128 + 1;
          der[offset++] = length;
        } else {
          der = new Uint8Array(length + 2);
          der[offset++] = 48;
          der[offset++] = length;
        }
        der[offset++] = 2;
        der[offset++] = r.length;
        der.set(r, offset);
        offset += r.length;
        der[offset++] = 2;
        der[offset++] = s.length;
        der.set(s, offset);
        return der;
      }

      /**
       * (private function, only called by `convertEcdsaIeee1363ToDer`)
       * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts#L311
       *
       * Transform a big integer in big endian to minimal unsigned form which has
       * no extra zero at the beginning except when the highest bit is set.
       *
       * @param {Uint8Array} bytes
       *
       */
      function toUnsignedBigNum(bytes) {
        // Remove zero prefixes.
        let start = 0;
        while (start < bytes.length && bytes[start] == 0) {
          start++;
        }
        if (start == bytes.length) {
          start = bytes.length - 1;
        }
        let extraZero = 0;

        // If the 1st bit is not zero, add 1 zero byte.
        if ((bytes[start] & 128) == 128) {
          // Add extra zero.
          extraZero = 1;
        }
        const res = new Uint8Array(bytes.length - start + extraZero);
        res.set(bytes.subarray(start), extraZero);
        return res;
      }

      /**
       * Code modified from https://github.com/github/webauthn-json/blob/e932b3585fa70b0bd5b5a4012ba7dbad7b0a0d0f/src/webauthn-json/base64url.ts#L23
       * @param {string} input
       */
      var stringToBase64urlString = function(input) {
          const base64String = btoa(input);
          return base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
      }

      /**
       * Function to send a message. If this page is embedded as an iframe we'll use window.top.postMessage. Otherwise we'll display it in the DOM.
       * @param type message type. Can be "PUBLIC_KEY_CREATED", "BUNDLE_INJECTED" or "STAMP"
       * @param value message value
       */
      var sendMessageUp = function(type, value) {
        if (window.top !== null) {
          window.top.postMessage({
              "type": type,
              "value": value,
          }, '*')
        }
        logMessage(`⬆️ Sent message ${type}: ${value}`)
      }

      /**
       * Function to log a message and persist it in the page's DOM.
       */
      var logMessage = function(content) {
        var messageLog = document.getElementById("message-log");
        var message = document.createElement("p")
        message.innerText = content;
        messageLog.appendChild(message);
      }

      /**
      * Convert a JSON Web Key private key to a public key and export the public
      * key in raw format.
      * @return {Uint8array}
      */
      var p256JWKPrivateToPublic = async function(jwkPrivate) {
        // make a copy so we don't modify the underlying object
        const jwkPrivateCopy = { ... jwkPrivate }
        // change jwk so it will be imported as a public key
        delete jwkPrivateCopy.d;
        jwkPrivateCopy.key_ops = ["verify"];

        var publicKey =  await window.crypto.subtle
          .importKey("jwk", jwkPrivateCopy, { name: "ECDSA", namedCurve: "P-256" }, true, ["verify"]);
        var buffer = await crypto.subtle.exportKey("raw", publicKey);
        return new Uint8Array(buffer)
      }

      /**
       * Returns a CryptoKey from a P256 private key bytes
       * This is a bit awkward because webcrypto can't import raw private key bytes.
       * We first convert these to pkcs8 bytes before importing.
       * @param {Uint8Array} privateKeyBytes
       */
      var importRecoveryCredential = async function(privateKeyBytes) {
        var privateKeyHexString = uint8arrayToHexString(privateKeyBytes);

        // Specific byte-sequence for curve prime256v1 (DER encoding)
        var hexString = "308141020100301306072a8648ce3d020106082a8648ce3d030107042730250201010420" + privateKeyHexString
        var pkcsBytes = new Uint8Array(hexString.match(/../g).map(h=>parseInt(h,16)))
        //var pkcs8Bytes = bufferFromHexString();

        var key = await window.crypto.subtle
          .importKey("pkcs8", pkcsBytes, { name: "ECDSA", namedCurve: "P-256" }, true, ["sign"]);
        return key
      }

      /**
       * Accepts a public key array buffer, and returns a buffer with the compressed version of the public key
       * @param {Uint8Array} rawPublicKey
       */
       var compressRawPublicKey = function(rawPublicKey) {
        const len = rawPublicKey.byteLength

        // Drop the y coordinate
        var compressedBytes = rawPublicKey.slice(0, 1 + len >>> 1)

        // Encode the parity of `y` in first bit
        compressedBytes[0] = 0x2 | (rawPublicKey[len-1] & 0x01)
        return compressedBytes
      }

      return {
        initEmbeddedKey,
        generateTargetKey,
        getEmbeddedKey,
        setEmbeddedKey,
        clearEmbeddedKey,
        importRecoveryCredential,
        compressRawPublicKey,
        p256JWKPrivateToPublic,
        convertEcdsaIeee1363ToDer,
        sendMessageUp,
        logMessage,
        base64urlEncode,
        stringToBase64urlString,
        uint8arrayToHexString,
        uint8arrayFromHexString,
        additionalAssociatedData
      }
    }();
  </script>

  <!--
    Script importing HPKE lib until we can replace it
    Because this is loaded as a module JSDOM can't load it properly
    Code in here isn't tested, so let's keep this to a minimum!
  -->
  <script type="module">
    // TODO: this should be bundled at build time or replaced with code written by Turnkey entirely.
    import * as hpke from "https://esm.sh/@hpke/core";

    // In memory spot for the recovery credential to live. We do NOT persist it to localStorage.
    var RECOVERY_CREDENTIAL_BYTES = null;

    document.addEventListener("DOMContentLoaded", async function () {
      await TKHQ.initEmbeddedKey();
      var embeddedKeyJwk = await TKHQ.getEmbeddedKey();
      var targetPubBuf = await TKHQ.p256JWKPrivateToPublic(embeddedKeyJwk);
      var targetPubHex = TKHQ.uint8arrayToHexString(targetPubBuf);
      document.getElementById("embedded-key").value = targetPubHex;
      TKHQ.sendMessageUp("PUBLIC_KEY_READY", targetPubHex)

      // TODO: find a way to filter messages and ensure they're coming from the parent window?
      // We do not want to arbitrarily receive messages from all origins.
      window.addEventListener("message", function(event) {
        if (event.data && event.data["type"] == "INJECT_RECOVERY_BUNDLE") {
          TKHQ.logMessage(`⬇️ Received message ${event.data["type"]}: ${event.data["value"]}`);
          onInjectBundle(event.data["value"])
        }
        if (event.data && event.data["type"] == "STAMP_REQUEST") {
          TKHQ.logMessage(`⬇️ Received message ${event.data["type"]}: ${event.data["value"]}`);
          onStampRequest(event.data["value"]);
        }
      }, false);

      /**
       * Event handlers to power the recovery flow in standalone mode
       * Instead of receiving events from the parent page, forms trigger them.
       * This is useful for debugging as well.
       */
      document.getElementById("inject").addEventListener("click", async function(e) {
        e.preventDefault();
        window.postMessage({
          "type": "INJECT_RECOVERY_BUNDLE",
          "value": document.getElementById("recovery-bundle").value,
        })
      }, false);
      document.getElementById("stamp").addEventListener("click", async function(e) {
        e.preventDefault();
        window.postMessage({
          "type": "STAMP_REQUEST",
          "value": document.getElementById("payload").value,
        })
      }, false);

      /**
       * DEBUG functionality only to clear the page's localStorage
       */
      document.getElementById("clear").addEventListener("click", TKHQ.clearEmbeddedKey);
    }, false);

    /**
     * Function triggered when INJECT_RECOVERY_BUNDLE event is received.
     * The `bundle` param is the concatenation of a public key and an encrypted payload.
     * For example:
     * 04c1faba5812bde458fdbf505dc1fc9dc1eb3f7c8fbbc3284d399bcc8eef8d72f29baf967cd6f2b207005d86b74a51aff9525c553afbad4ac0835e47ffcf3623a2
     * +
     * 80b4a5708e2f95aa18dad9d90b8f49490893d1408a326c78abaa8a0d563ea7dbc28aaa35913f9d698be30d015afda49c
     * ==
     * 04c1faba5812bde458fdbf505dc1fc9dc1eb3f7c8fbbc3284d399bcc8eef8d72f29baf967cd6f2b207005d86b74a51aff9525c553afbad4ac0835e47ffcf3623a280b4a5708e2f95aa18dad9d90b8f49490893d1408a326c78abaa8a0d563ea7dbc28aaa35913f9d698be30d015afda49c
     * @param {string} bundle
     */
    var onInjectBundle = async function(bundle) {
        if (bundle.length <= 130) {
          throw new Error("bundle size is too low. Expecting an uncompressed public key (130 chars) and an encrypted bundle!")
        }

        var encappedKeyHex = bundle.substring(0, 130);
        var encappedKeyBuf = TKHQ.uint8arrayFromHexString(encappedKeyHex);

        var ciphertextHex = bundle.substring(130);
        var ciphertextBuf = TKHQ.uint8arrayFromHexString(ciphertextHex);

        var embeddedKeyJwk = await TKHQ.getEmbeddedKey();
        var recoveryCredentialBytes = await HpkeDecrypt(
          {
            ciphertextBuf,
            encappedKeyBuf,
            receiverPrivJwk: embeddedKeyJwk,
          });

        RECOVERY_CREDENTIAL_BYTES = recoveryCredentialBytes;
        TKHQ.sendMessageUp("BUNDLE_INJECTED", true)
    }
    /**
     * Function triggered when STAMP_REQUEST event is received.
     * @param {string} payload hex-encoded string containing the bytes to sign.
     */
    var onStampRequest = async function(payload) {
      if (RECOVERY_CREDENTIAL_BYTES === null) {
        throw new Error("cannot sign payload without credential. Credential bytes are null");
      }
      var challengeBytes = TKHQ.uint8arrayFromHexString(payload);
      var recoveryKey = await TKHQ.importRecoveryCredential(RECOVERY_CREDENTIAL_BYTES)
      var signatureIeee1363 = await window.crypto.subtle.sign(
        {
            name: "ECDSA",
            hash: {name: "SHA-256"},
        },
        recoveryKey,
        challengeBytes.buffer
      );

      var derSignature = TKHQ.convertEcdsaIeee1363ToDer(new Uint8Array(signatureIeee1363));
      var derSignatureHexString = TKHQ.uint8arrayToHexString(derSignature);

      // This is a bit of a pain, but we need to go through this:
      // - Key needs to be exported to JWK first
      // - Then imported without the private "d" component, and exported to get the public key
      //   ^^ (that's what `p256JWKPrivateToPublic` does)
      // - Finally, compress the public key.
      var jwkKey = await crypto.subtle.exportKey("jwk", recoveryKey);
      var publicKey = await TKHQ.p256JWKPrivateToPublic(jwkKey);
      var compressedPublicKey = TKHQ.compressRawPublicKey(publicKey);

      var stamp = {
        publicKey: TKHQ.uint8arrayToHexString(compressedPublicKey),
        scheme: "SIGNATURE_SCHEME_TK_API_P256",
        signature: derSignatureHexString,
      };

      var stampHeaderValue = TKHQ.stringToBase64urlString(JSON.stringify(stamp));
      sendMessageUp("STAMP", stampHeaderValue)
    }

    /**
     * Decrypt the ciphertext (ArrayBuffer) given an encapsulation key (ArrayBuffer)
     * and the receivers private key (JSON Web Key).
     */
    var HpkeDecrypt = async function({
      ciphertextBuf,
      encappedKeyBuf,
      receiverPrivJwk,
    }) {
      var kemContext = new hpke.DhkemP256HkdfSha256();
      var receiverPriv = await kemContext.importKey("jwk", {...receiverPrivJwk}, false);


      var suite = new hpke.CipherSuite({
        kem: kemContext,
        kdf: new hpke.HkdfSha256(),
        aead: new hpke.Aes256Gcm(),
      });

      var recipientCtx = await suite.createRecipientContext({
        recipientKey: receiverPriv,
        enc: encappedKeyBuf,
        info: new TextEncoder().encode("turnkey_hpke"),
      });

      var receiverPubBuf = await TKHQ.p256JWKPrivateToPublic(receiverPrivJwk);
      var aad = TKHQ.additionalAssociatedData(encappedKeyBuf, receiverPubBuf);
      var res;
      try {
        res = await recipientCtx.open(ciphertextBuf, aad);
      } catch (e) {
        throw new Error("decryption failed: " + e);
      }
      return res
    }
  </script>
</body>
</html>
