<!doctype html>
<html class="no-js" lang="">

<head>
  <meta charset="utf-8">
  <title>Turnkey Recovery</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      text-align: center;
      font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
    }
    label {
      display:inline-block;
      width: 8em;
    }
    input[type=text] {
      width: 40em;
      margin: 0.5em;
      font-family: 'Courier New', Courier, monospace;
      font-size: 1em;
      height: 1.8em;
      color: rgb(18, 87, 18);
      border: 1px rgb(217, 240, 221) solid;
      border-radius: 4px;
    }
    input:disabled {
      background-color: rgb(239, 243, 240);
    }
    #decrypted {
      width: 60em;
      background-color: rgb(58, 152, 81);
      color: white;
      height: 2em;
      font-weight: bold;
      text-align: center;
    }
    #clear {
      color: white;
      width: 7em;
      font-size: 1em;
      padding: 0.38em;
      border-radius: 4px;
      background-color: rgb(187, 100, 100);
      border: 1px rgb(112, 42, 42) solid;
      cursor: pointer;
    }
    #ecdh {
      color: white;
      width: 7em;
      font-size: 1em;
      padding: 0.38em;
      border-radius: 4px;
      background-color: rgb(50, 44, 44);
      border: 1px rgb(33, 33, 33) solid;
      cursor: pointer;
    }
    .hidden { display: none; }
  </style>
</head>

<body>
  <h2>Recovery Initialization</h2>
  <p><em>This public key will be sent along with your email inside of a <code>CREATE_RECOVERY</code> activity</em></p>
  <form>
    <label>Embedded key</label>
    <input type="text" name="embedded-key" id="embedded-key" disabled/>
    <button id="clear">Reset Key</button>
  </form>
  <br>
  <br>
  <br>
  <h2>Recovery Key Decryption</h2>
  <p><em>Values for these fields will come from an email. For now, we can simulate this locally: see instructions <a href="https://github.com/tkhq/recovery#running-a-fake-recovery" target="_blank">here</a></em></p>
  <form>
    <label>Enclave Auth Key</label>
    <input type="text" name="quorum-key" id="enclave-auth-key" value="040c901d423c831ca85e27c73c263ba132721bb9d7a84c4f0380b2a6756fd601331c8870234dec878504c174144fa4b14b66a651691606d8173e55bd37e381569e"/>
    <br>

    <label>Encapped Key</label>
    <input type="text" name="quorum-key" id="encapped-key" value="02" />
    <br>

    <label>Encapped Key Signature</label>
    <input type="text" name="quorum-key" id="encapped-key-signature" value="02" />
    <br>

    <label>Ciphertext</label>
    <input type="text" name="encrypted-key" id="ciphertext" placeholder="Paste your encrypted recovery key ciphertext" value="02"/>
    <br>

    <br>
    <input type="text" name="decrypted" id="decrypted" value="" class="hidden"/>
    <br>
    <br>
    <button id="decrypt">Decrypt</button>

  </form>

  <script type="module">
    import * as hpke from "https://esm.sh/@hpke/core";
    document.addEventListener("DOMContentLoaded", async function () {

      // await verifyHardcodedTest()
      await initEmbeddedKey();
      var embeddedKeyJwk = await getEmbeddedPrivateKey();
      var targetPubBuf = await p256JWKPrivateToPublic(embeddedKeyJwk);
      var targetPubHex = bufferToHexString(targetPubBuf);
      document.getElementById("embedded-key").value = targetPubHex;

      document.getElementById("clear").addEventListener("click", clearEmbeddedKey);
      document.getElementById("decrypt").addEventListener("click", async function(e) {
        e.preventDefault();

        var enclaveAuthKeyHex = document.getElementById("enclave-auth-key").value;
        var enclaveAuthKeyBuf = bufferFromHexString(enclaveAuthKeyHex);

        var encappedKeyHex = document.getElementById("encapped-key").value;
        var encappedKeyBuf = bufferFromHexString(encappedKeyHex);

        var encappedKeyEnclaveAuthSignatureHex = document.getElementById("encapped-key-signature").value;
        var encappedKeyEnclaveAuthSignatureBuf = bufferFromHexString(encappedKeyEnclaveAuthSignatureHex);

        var ciphertextHex = document.getElementById("ciphertext").value;
        var ciphertextBuf = bufferFromHexString(ciphertextHex);

        var res = await verifyAndDecrypt(
          {
            enclaveAuthKeyBuf,
            encappedKeyEnclaveAuthSignatureBuf,
            encappedKeyBuf,
            ciphertextBuf,
            receiverPrivJwk: embeddedKeyJwk
          }
          );
        var decrypted = new TextDecoder().decode(res)

        // Make the decrypt button disappear
        e.target.classList.add("hidden");
        document.getElementById("decrypted").value = "DECRYPTED! Recovery key: " + decrypted;
        document.getElementById("decrypted").classList.remove("hidden");
      })
    }, false);

    /*
    * Convert a JSON Web Key private key to a public key and export the public
    * key in raw format.
    */
    var p256JWKPrivateToPublic = async function(jwkPrivate) {
      // make a copy so we don't modify the underlying object
      const jwkPrivateCopy = { ... jwkPrivate }
      // change jwk so it will be imported as a public key
      delete jwkPrivateCopy.d;
      jwkPrivateCopy.key_ops = ["verify"];

      var publicKey =  await window.crypto.subtle
        .importKey("jwk", jwkPrivateCopy, { name: "ECDSA", namedCurve: "P-256" }, true, ["verify"]);
      return await crypto.subtle.exportKey("raw", publicKey);
    }

    var initEmbeddedKey = async function() {
      var retrievedKey = await getEmbeddedPrivateKey();
      if (retrievedKey === null) {
        var targetKey = await generateTargetKey();
        setEmbeddedKey(targetKey)
      } else {
        // Nothing to do, key is correctly initialized
      }
    }


    const TURNKEY_EMBEDDED_KEY = "TURNKEY_EMBEDDED_KEY"

    // Gets the current embedded private key JWK. Returns `null` if not found.
    var getEmbeddedPrivateKey = async function() {
      var jwtKey = window.localStorage.getItem(TURNKEY_EMBEDDED_KEY)
      if (jwtKey === null || jwtKey === undefined || jwtKey === "") {
        return null
      } else {
        return JSON.parse(jwtKey);
      }
    }

    var setEmbeddedKey = function(targetKey) {
      console.log("setting (stringified)", JSON.stringify(targetKey))
      return window.localStorage.setItem(TURNKEY_EMBEDDED_KEY, JSON.stringify(targetKey))
    }

    var clearEmbeddedKey = function() {
      window.localStorage.removeItem(TURNKEY_EMBEDDED_KEY)
    }

    /*
    * Import a raw public key as a `CryptoKey`
    */
    var importPublicKey = async function(publicKey) {
      return await crypto.subtle.importKey(
        "raw",
        publicKey,
        { name: "ECDSA", namedCurve: "P-256" },
        true,
        ["verify"]
      );
    }

    /*
     * Takes a hex string (e.g. "e4567ab") and returns an array buffer (Uint8Array)
     */
    var bufferFromHexString = function(hexString) {
      return new Uint8Array(hexString.match(/../g).map(h=>parseInt(h,16))).buffer;
    }

    /*
     * Takes a hex string (e.g. "e4567ab") and returns an array buffer (Uint8Array)
     */
     var bufferToHexString = function(buffer) {
      return [...new Uint8Array(buffer)]
          .map(x => x.toString(16).padStart(2, '0'))
          .join('');
    }

    /*
    * Verify the signature from the enclave auth key and then decrypt.
    */
    var verifyAndDecrypt = async function(
      {
        enclaveAuthKeyBuf,
        encappedKeyEnclaveAuthSignatureBuf,
        ciphertextBuf,
        encappedKeyBuf,
        receiverPrivJwk,
      }
    ) {

      var enclaveAuthKey = await importPublicKey(enclaveAuthKeyBuf);

      var verified = await crypto.subtle.verify(
        { name: 'ECDSA', namedCurve: 'P-256',  hash: "SHA-256" },
        enclaveAuthKey,
        encappedKeyEnclaveAuthSignatureBuf,
        encappedKeyBuf,
      );
      if (!verified) {
        window.alert("Invalid Enclave Auth Signature over Encapped Key")
        throw Error("Invalid Enclave Auth Signature over Encapped Key");
      }

      return await baseDecrypt({
        ciphertextBuf,
        encappedKeyBuf,
        receiverPrivJwk,
      });
    }

    /*
    * Decrypt the ciphertext (ArrayBuffer) given an encapsulation key (ArrayBuffer)
    * and the receivers private key (JSON Web Key).
    */
    var baseDecrypt = async function({
        ciphertextBuf,
        encappedKeyBuf,
        receiverPrivJwk,
      }) {
        var kemContext = new hpke.DhkemP256HkdfSha256();
        var receiverPriv = await kemContext.importKey("jwk", {...receiverPrivJwk}, false);


        var suite = new hpke.CipherSuite({
          kem: kemContext,
          kdf: new hpke.HkdfSha256(),
          aead: new hpke.Aes256Gcm(),
        });

        var recipientCtx = await suite.createRecipientContext({
          recipientKey: receiverPriv,
          enc: encappedKeyBuf,
          info: new TextEncoder().encode("turnkey_hpke"),
        });

        var receiverPubBuf = await p256JWKPrivateToPublic(receiverPrivJwk);
        var aad = additionalAssociatedData(encappedKeyBuf, receiverPubBuf);
        var res;
        try {
          res = await recipientCtx.open(ciphertextBuf, aad);
        } catch (e) {
          console.log("decryption failed", e)
          alert("decryption failed", e)
        }

        return res
      }

    /*
    * Generate a key to encrypt to and export it as a JSON Web Key.
    */
    var generateTargetKey = async function() {
        var kemContext = new hpke.DhkemP256HkdfSha256();
        var kp = await kemContext.generateKeyPair();

        return await crypto.subtle.exportKey("jwk", kp.privateKey);
      }

    /*
    * Additional Associated Data (AAD) in the format dictated by the enclave_encrypt crate.
    */
    var additionalAssociatedData = function(
        senderPubBuf,
        receiverPubBuf,
      ) {
        var s = Array.from(new Uint8Array(senderPubBuf));
        var r = Array.from(new Uint8Array(receiverPubBuf));
        return new Uint8Array([...s, ...r]);
      }

      var verifyHardcodedTest = async function() {
        var authKeyHex = "040c901d423c831ca85e27c73c263ba132721bb9d7a84c4f0380b2a6756fd601331c8870234dec878504c174144fa4b14b66a651691606d8173e55bd37e381569e";
        var authKeyBuf = bufferFromHexString(authKeyHex);
        var authKey = await crypto.subtle.importKey(
          "raw",
          authKeyBuf,
          { name: "ECDSA", namedCurve: "P-256" },
          true,
          ["verify"]
        );

        var encappedKeyHex = "0488876afb290045e2d282d59f6f2d3256198c0eba83088570b9d5665033372680740c14b5b5b78c5484869b2e832c1242fa52c36dd9cff754160f0245c11a41ee";
        var encappedKeyBuf = bufferFromHexString(encappedKeyHex);

        var encappedKeySignatureHex = "b7a61b5282723f276cbd9ee19860bc92eca5a6414e73a2e5755c004ba0319c88204b0073e731476ca67f9b0284c0b946ae4c9eaa6b18ae4c53eab8068aebad3b";
        var encappedSignatureBuf = bufferFromHexString(encappedKeySignatureHex);

        var verified = await crypto.subtle.verify(
            { name: 'ECDSA', namedCurve: 'P-256', hash: "SHA-256" },
            authKey,
            encappedSignatureBuf,
            encappedKeyBuf,
          );

        if (verified === true) {
          alert("it verified")
        } else {
          alert("verification failed")
        }
      }
  </script>
</body>
</html>
